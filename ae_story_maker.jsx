/*ae_story_makermake videos from several files.import all files4 post4 story(add more and name sequentially)selects random videos and puts them in the comps, trimming and sequencing as needd to fill the entire duration of the comp*/(function story_maker() {  /*       some string prototypes to be used      */      if (typeof String.prototype.startsWith != 'function') {        String.prototype.startsWith = function (str){          return this.indexOf(str) == 0;        };      }      if (typeof String.prototype.endsWith != 'function') {        String.prototype.endsWith = function (str){          return this.slice(-str.length) == str;        };      }      if (typeof String.prototype.contains != 'function') {        String.prototype.contains = function (str){          return this.indexOf(str) !== -1;        };      }      if (typeof String.prototype.getExtension != 'function') {        String.prototype.getExtension = function (){          var dotP = this.lastIndexOf('.')+1;          return !dotP ? false : dotP !== this.length ? this.substr(dotP) : '';        };      }      if (typeof String.prototype.getBasename != 'function') {        String.prototype.getBasename = function (){          var dotP = this.lastIndexOf('.');          if (dotP == -1) {            return this;          } else if (dotP !== this.length) {            return this.substr(0,dotP);          } else {            return this;          }        };      }      if (typeof String.prototype.trim != 'function') {        String.prototype.trim = function() {          return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');        };      }  function createCompFromComp (myComp, myName) {       try{        var newComp;        newComp = app.project.items.addComp(myName, myComp.width, myComp.height, 1, myComp.duration, myComp.frameRate);        newComp.layers.add(myComp);     //Adds file to comp        return newComp;      } catch(err){       // alert("Error at line# " + err.line.toString() + "\r" + err.toString());       return null;     }   }   function searchInFolder (name, folderName,cs) {    var myElem = null;    currFolder = projectItemSearch(folderName,"folder",cs);    if (!currFolder) return false;    if (!name) return false;    for (var i = 1; i <= currFolder.numItems; i++) {    	myElem = currFolder.items[i];    	if (myElem instanceof CompItem) {    		if (cs) {    			if (myElem.name === name) return myElem;    		} else {    			if (myElem.name.toUpperCase() === name.toUpperCase()) return myElem;    		}    	}    }    return false;  }  function projectItemSearch (name, type,cs) {   var items = app.project.items;   var result = itemSearchVec(items, name, type,cs);   if (result.length >0) return result[0];   return false; } function itemSearch(items,name, type,cs) {   var result = itemSearchVec(items, name, type,cs);   if (result.length >0) return result[0];   return false; } function itemSearchVec(items,name, type, cs) {   var result = [];   if ( (type == "") || (type == null) ) {    type = "comp";  }  if (typeof name != "string") return result;  if ( (items === undefined) || (items === null) ) items = app.project.items;  for (var i = 1; i <= items.length; i++){    myElem = items[i];    if (myElem.name === name) {     switch(type) {      case "solid":      if ( (myElem.mainSource != null) && (myElem.mainSource != undefined) && (myElem.mainSource instanceof SolidSource) ) {       result.push(myElem);     }     break;     case "comp":     if (myElem instanceof CompItem) result.push(myElem);     break;     case "folder":     if (myElem instanceof FolderItem) result.push(myElem);     break;   } }}return result;}function projectItemSearchVec(name, type,cs) {	var items = app.project.items;	return itemSearchVec(items, name, type,cs);}function projectItemContains(name, type, cs) {	var items = app.project.items;	var result = [];	if ( (type == "") || (type == null) ) {		type = "comp";	}	if (typeof name != "string") return result;	for (var i = 1; i <= items.length; i++){		myElem = items[i];		if (myElem.name.contains(name)) {			switch(type) {				case "solid":				if ( (myElem.mainSource != null) && (myElem.mainSource != undefined) && (myElem.mainSource instanceof SolidSource) ) {					result.push(myElem);				}				break;				case "comp":				if (myElem instanceof CompItem) result.push(myElem);				break;				case "folder":				if (myElem instanceof FolderItem) result.push(myElem);				break;			}		}	}	return result;}function populateArrayFromFolder(folderName) {  var result = [];  var items = app.project.rootFolder.items;  if (folderName != null && folderName !="") {    var myFolder = itemSearch (app.project.items, folderName, "folder");    if (!myFolder) return result;    items = myFolder.items;  }  if (items == undefined) {    return result;  }    // project items start at 1    for (var i = 1; i <= items.length; i++) {      var vid = items[i];      if ( (vid instanceof FootageItem) ) {        result.push(vid);      }    }    return result;  }/*  sets the given p property to the default value def  removes all keyframes and expressions  */  function reset (p, def) {  	if (p.expression!=="") p.expression = "";  	while (p.numKeys>0) p.removeKey(1);  	p.setValue(def);    return;  }/*  resets all properties of the given layer to the app defaults  */  function resetProperties (comp, layer) {   L = layer;   D3 = L.threeDLayer;    // default scale is [100,100,100]    reset(L.transform.scale, [100,100,100]);    // default rotation is 0, orientation is [0,0,0]    if (D3) {    	reset(L.transform.xRotation, 0);    	reset(L.transform.yRotation, 0);    	reset(L.transform.zRotation, 0);    } else{    	reset(L.transform.rotation, 0);    }    // orientation    if (D3){    	reset(L.transform.orientation, [0,0,0]);    }    // default anchor point is centered in layer    def = L.source ? [L.width/2, L.height/2, 0] : [0,0,0];    reset(L.transform.anchorPoint, def);    // default position is centered in comp    def = L.parent ? [0,0,0] : [comp.width/2,comp.height/2, 0];    if (L.transform.position.dimensionsSeparated) {    	reset(L.transform.xPosition, def[0]);    	reset(L.transform.yPosition, def[1]);    	if (D3) reset(L.transform.zPosition, def[2]);    } else {    	reset(L.transform.position, def);    }    // default opacity is 100    reset(L.transform.opacity, [100]);  }  function adjustTime (thelayer, d) {   var inp, outp;   if (thelayer.source.duration > d) {    inp = (thelayer.source.duration-d)/2;    outp = inp + d;  } else {    inp = 0;    outp = thelayer.source.duration;  }  thelayer.inPoint = inp;  thelayer.outPoint = outp;}function adjustScaleToComp (comp, thelayer) {	thelayer.parent = null;	resetProperties(comp, thelayer);	var myRect = thelayer.sourceRectAtTime(0,true);	var myScale = thelayer.property("Scale").value;	// this scales the layer to fill the entire comp, cropping the content if needed	var myNewScale = myScale*Math.max(comp.width/myRect.width,comp.height/myRect.height);	// if using a selector for fit/fill, use the following for fitted scale	// 	myNewScale = myScale*Math.min(comp.width/myRect.width,comp.height/myRect.height);	thelayer.property("Scale").setValue(myNewScale);	thelayer.property("Position").setValue([comp.width/2, comp.height/2]);}function sequenceLayers(thelayers) {  var offset = 0;  for (var i=1;i <= thelayers.length;i++) {    var L = thelayers[i];    if (!L.locked) {      L.startTime = -L.inPoint + offset;      offset = L.outPoint;    }  }}function getLayerActiveDuration(thelayer) {  return thelayer.outPoint-thelayer.inPoint;}function getVideoLayers (layers) {  var videoLayers = [];  for (var i=1;i <= layers.length;i++) {    var thelayer = layers[i];      if (thelayer instanceof AVLayer && thelayer.source.frameDuration < 1 && !thelayer.locked) // it's a video and unlocked        videoLayers.push(thelayer);    }    return videoLayers;  }  function getActiveVideoLayersDuration(comp){    var totalFootageDuration = 0;    var videoLayers = getVideoLayers(comp.layers);    for (var i = videoLayers.length - 1; i >= 0; i--) {      totalFootageDuration += getLayerActiveDuration(videoLayers[i]);    }    return totalFootageDuration;  }  function AdjustLayersDuration(comp) {  // check if all comp duration is covered  // adjust video layers that have more footage if needed  // add more layers if not enough!  var totalFootageDuration = getActiveVideoLayersDuration(comp);  var videoLayers = getVideoLayers(comp.layers);  var diffDuration = comp.duration - totalFootageDuration;  while (diffDuration > 0.01 && videoLayers.length > 0) {    var increment = diffDuration/videoLayers.length;    for (var i = videoLayers.length - 1; i >= 0; i--) {      L = videoLayers[i];      layerActiveDuration = getLayerActiveDuration(L);      if (L.source.duration > layerActiveDuration) {        adjustTime (L, layerActiveDuration+increment);      } else {        videoLayers.splice(i,1);      }    }    totalFootageDuration = getActiveVideoLayersDuration(comp);    diffDuration = comp.duration - totalFootageDuration;  }}function getRandomSubarray(arr, size) {  var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;  while (i-- > min) {    index = Math.floor((i + 1) * Math.random());    temp = shuffled[index];    shuffled[index] = shuffled[i];    shuffled[i] = temp;  }  return shuffled.slice(min);}function shuffle(array) {  var currentIndex = array.length, temporaryValue, randomIndex;  // While there remain elements to shuffle...  while (0 !== currentIndex) {    // Pick a remaining element...    randomIndex = Math.floor(Math.random() * currentIndex);    currentIndex -= 1;    // And swap it with the current element.    temporaryValue = array[currentIndex];    array[currentIndex] = array[randomIndex];    array[randomIndex] = temporaryValue;  }  return array;}function populateComp (comp, compIndex, amountItems, itemsArray) {  var videosDuration = 0;  var randomVideos = [];  for (var i = 0; i < amountItems; i++) {    var randomVideo = itemsArray[i+(compIndex*amountItems)];    randomVideos.push(randomVideo);    videosDuration += randomVideo.duration;  }  while (videosDuration < comp.duration) {    // needs more videos    i++;    randomVideo = itemsArray[i+(compIndex*amountItems)];    randomVideos.push(randomVideo);    videosDuration += randomVideo.duration;  }  amountItems = randomVideos.length;  var dur = comp.duration/amountItems;  var remaining = comp.duration;  for (var i = 0; i < amountItems; i++) {    var currLayer = comp.layers.add(randomVideos[i]);    adjustScaleToComp(comp, currLayer);    currLayer.name = i;    currLayer.moveToEnd();    adjustTime(currLayer, dur);    var layerDur = currLayer.outPoint-currLayer.inPoint    remaining -= layerDur;    dur = remaining / (amountItems-(i+1));  }  AdjustLayersDuration(comp);  sequenceLayers(comp.layers);}function makeNewComps(amountItems, compsArray, dupesFolder, prefix) {  var footageItems = amountItems; // items per video  var cantVideos = Math.floor(importedVideos.length / footageItems);  for (var n=0;n<cantVideos;n++) {    var randomIndex = Math.floor(Math.random() * compsArray.length);    var newComp = compsArray[randomIndex].duplicate();        newComp.parentFolder = dupesFolder;    newComp.name = prefix + "_"+n;    // var usedVideos = getRandomSubarray(importedVideos,footageItems);    populateComp(newComp, n, amountItems, importedVideos);  }  return cantVideos;}function formatMessage(amount, compName) {  var compos = " composition";  if (amount >1) {    compos +="s";  }  var msg = "Created " + amount + " " + compName + compos + "\r";  return msg;}app.beginUndoGroup("story maker makes me happy");var proj = app.project;var folderObj = Folder.selectDialog();var fileArray = folderObj.getFiles ();var ASSETS_FOLDER = "00-imported-assets";var COMPS_FOLDER = "00-created-comps";if (fileArray) {  movFolder = projectItemSearch(ASSETS_FOLDER, "folder");  if (!movFolder) {   movFolder = proj.items.addFolder(ASSETS_FOLDER); } for (var i=0;i<fileArray.length;i++) {   fItem = null;   try {    fItem = proj.importFile(new ImportOptions(File(fileArray[i])));  } catch(err) {		// logger.log("\tERROR: " + err.message);  }  if (fItem !== null) fItem.parentFolder = movFolder;}var importedVideos = shuffle(populateArrayFromFolder(ASSETS_FOLDER));	// var usedVideos = new Array(importedVideos.length);	dupesFolder = projectItemSearch(COMPS_FOLDER, "folder");  if (!dupesFolder) {   dupesFolder = proj.items.addFolder(COMPS_FOLDER); } var stories = shuffle(projectItemContains("story_")); var posts = shuffle(projectItemContains("square_")); var amountStories = makeNewComps(3, stories, dupesFolder, "new-story"); var amountPosts = makeNewComps(6, posts, dupesFolder, "new-post"); alert("Story Maker Makes me Happy\r" + formatMessage(amountStories, "Story") + formatMessage(amountPosts, "Post") + "\rGoodbye and thanks for all the fish!");}app.endUndoGroup();})();